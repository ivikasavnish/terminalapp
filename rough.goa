package main

import (
	"fmt"
	"github.com/wailsapp/wails/v2/pkg/runtime"
	"golang.org/x/net/context"
	"io"
)

func (a *App) ExecuteInteractiveCommand(profile, command string) error {
	client, err := a.getSSHClient(profile)
	if err != nil {
		return fmt.Errorf("failed to get SSH client: %v", err)
	}

	session, err := client.NewSession()
	if err != nil {
		return fmt.Errorf("failed to create session: %v", err)
	}

	stdout, err := session.StdoutPipe()
	if err != nil {
		session.Close()
		return fmt.Errorf("failed to get stdout pipe: %v", err)
	}

	stderr, err := session.StderrPipe()
	if err != nil {
		session.Close()
		return fmt.Errorf("failed to get stderr pipe: %v", err)
	}

	if err := session.Start(command); err != nil {
		session.Close()
		return fmt.Errorf("failed to start command: %v", err)
	}

	ctx, cancel := context.WithCancel(a.ctx)

	ic := &InteractiveCommand{
		Session: session,
		Stdout:  stdout,
		Stderr:  stderr,
		Cancel:  cancel,
	}

	commandMutex.Lock()
	interactiveCommands[profile] = ic
	commandMutex.Unlock()

	go func() {
		defer session.Close()
		defer func() {
			commandMutex.Lock()
			delete(interactiveCommands, profile)
			commandMutex.Unlock()
		}()

		stdoutDone := make(chan bool)
		stderrDone := make(chan bool)

		go a.streamOutput(ctx, stdout, "stdout", profile, stdoutDone)
		go a.streamOutput(ctx, stderr, "stderr", profile, stderrDone)

		select {
		case <-ctx.Done():
			return
		case <-stdoutDone:
			<-stderrDone
		case <-stderrDone:
			<-stdoutDone
		}

		if err := session.Wait(); err != nil {
			runtime.EventsEmit(a.ctx, "command_output", map[string]string{
				"profile": profile,
				"type":    "error",
				"data":    fmt.Sprintf("Command finished with error: %v", err),
			})
		} else {
			runtime.EventsEmit(a.ctx, "command_output", map[string]string{
				"profile": profile,
				"type":    "info",
				"data":    "Command finished successfully",
			})
		}
	}()

	return nil
}

func (a *App) streamOutput(ctx context.Context, r io.Reader, outputType string, profile string, done chan<- bool) {
	defer close(done)
	buf := make([]byte, 1024)
	for {
		select {
		case <-ctx.Done():
			return
		default:
			n, err := r.Read(buf)
			if n > 0 {
				runtime.EventsEmit(a.ctx, "command_output", map[string]string{
					"profile": profile,
					"type":    outputType,
					"data":    string(buf[:n]),
				})
			}
			if err != nil {
				if err != io.EOF {
					runtime.EventsEmit(a.ctx, "command_output", map[string]string{
						"profile": profile,
						"type":    "error",
						"data":    fmt.Sprintf("Error reading output: %v", err),
					})
				}
				return
			}
		}
	}
}
